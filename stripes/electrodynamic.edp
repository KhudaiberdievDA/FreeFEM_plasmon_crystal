load	"gmsh"
load	"Element_Mixte"

/* Parameters. */

verbosity = 0;

complex dieleps = 12;			// Dielectric epsilon.
real sigma0 = 5;			// 2D conductivity 4 * pi * sigma / c.
real tau = 1.0 / (2 * pi * 1.5 * 25e-4);	// c * tau / period.
real k = 0.69;				// Wavevector times period.
					// Period is set to 1.0.
int nanim = 40;				// Number of animation frames.

/* Labels and scale factor (should be synchronized with GMSH file). */
int inl = 1;
int outl = 2;
int srcl = 3;
int m1 = 4;
int m2 = 5;
int m3 = 6;
int bl = 7;
int st = 8;
int back = 9;
int diel = 10;
int air = 11;
real scale = 1.0 / 1e3;

/* [Macros] Conductivity tensor and vectors of electric and magnetic fields. */

/* Load mesh. */
mesh Th = gmshload("stripe.msh");
Th = movemesh(Th, [scale * x, scale * y]);

/* Check the labels. */
cout << "Labels: " << labels(Th) << endl;
cout << "Area = " << Th.measure << endl;

/* Get the positions of planes m1, m2, m3 and the back of the sample. */
real y1 = int1d(Th, m1) (y) / int1d(Th, m1) (1);
real y2 = int1d(Th, m2) (y) / int1d(Th, m2) (1);
real y3 = int1d(Th, m3) (y) / int1d(Th, m3) (1);
real d = int1d(Th, back) (y) / int1d(Th, back) (1);
cout << "m1 = " << y1 << ", m2 = " << y2 << ", m3 = " << y3 << ", d = " <<
    d << endl;

/* Dielectric permittivity. */
func epsilon = 1 * (Th(x, y).region == air) +
    dieleps * (Th(x, y).region == diel);

/* Drude conductivity. */
func sigma = sigma0 / (1 - 1i * k * tau);

/* Electrodynamic problem, E||z polarization. */
varf dynamice(u, v)
	= int2d(Th) ([dx(v), dy(v)]' * [dx(u), dy(u)] -
	    epsilon * k^2 * v * u)
	- int1d(Th, st) (1i * k * sigma * v * u)
	- int1d(Th, inl) (1i * k * v * u)
	- int1d(Th, outl) (1i * k * v * u)
	+ int1d(Th, srcl) (1 * v);

/* Electrodynamic problem, H||z polarization. */
varf dynamich([ux, uy], [vx, vy])
	= int2d(Th) ((dx(vy) - dy(vx)) * (dx(uy) - dy(ux)) -
	    epsilon * k^2 * [vx, vy]' * [ux, uy])
	- int1d(Th, st) (1i * k * sigma *
	    (N.y * vx - N.x * vy) * (N.y * ux - N.x * uy))
	- int1d(Th, inl) (1i * k *
	    (N.y * vx - N.x * vy) * (N.y * ux - N.x * uy))
	- int1d(Th, outl) (1i * k *
	    (N.y * vx - N.x * vy) * (N.y * ux - N.x * uy))
	+ int1d(Th, srcl) (1 * vx)
	+ on(bl, uy = 0);

/* E||z (scalar) and H||xy (vector) function spaces. */
fespace Sh(Th, P2);
fespace Vh(Th, [P1, P1]);

/* E||xy (Nedelec, edge) and H||z (scalar) function spaces. */
fespace Veh(Th, RT1Ortho);
fespace Seh(Th, P1);

/* Auxiliary scalar field. */
Sh aux;

/*
 * E||z polarization.
 */

/* Unknown field. */
Sh<complex> Ez;

/* Solve dynamic linear system. */
{
	matrix<complex> A = dynamice(Sh, Sh);
	complex[int] b = dynamice(0, Sh);
	Ez[] = A^-1 * b;
}

/* Magnetic field. */
Vh<complex> [Hx, Hy] = [-1i / k * dy(Ez), 1i / k * dx(Ez)];

/* Output dynamic results. */
plot(Ez, value = true, fill = true, wait = true);

/* Find the amplitude of the waves. */
aux = abs(Ez);
real am = aux[].max;
real step = am / 20;

/* Visualize the wave. */
real[int] viso = -(am + step):step:(am + step);
for (int i = 0; i < nanim; i++) {
	aux = real(Ez) * cos(2 * pi * i / nanim) +
	    imag(Ez) * sin(2 * pi * i / nanim);
	plot(aux, value = true, fill = true, viso = viso, dim = 2);
}

/*
 * H||z polarization.
 */

/* Unknown field. */
Veh<complex> [Ex, Ey];

/* Solve dynamic linear system. */
{
	matrix<complex> A = dynamich(Veh, Veh);
	complex[int] b = dynamich(0, Veh);
	Ex[] = A^-1 * b;
}

/* Magnetic field. */
Seh<complex> Hz = -1i / k * (dx(Ey) - dy(Ex));

/* Output dynamic results. */
plot(Hz, value = true, fill = true, wait = true);

/* Find the amplitude of the waves. */
aux = abs(Hz);
am = aux[].max;
step = am / 20;

/* Visualize the wave. */
viso = -(am + step):step:(am + step);
for (int i = 0; i < nanim; i++) {
	aux = real(Hz) * cos(2 * pi * i / nanim) +
	    imag(Hz) * sin(2 * pi * i / nanim);
	plot(aux, value = true, fill = true, viso = viso, dim = 2);
}

/* Get the size of the computational domain. */
real[int] bb(4);
boundingbox(Th, bb);
cout << "Bounding box: x = [" << bb[0] << ", " << bb[1] <<
    "], y = [" << bb[2] << ", " << bb[3] << "]" << endl;

/* Example of symmetry extension. */
mesh Ih = square((bb[1] - bb[0]) * 10, (bb[3] - bb[2]) * 10,
    [bb[0] - (bb[1] - bb[0]) + (bb[1] - bb[0]) * x,
    bb[2] + (bb[3] - bb[2]) * y]);
fespace Sih(Ih, P2);
Sih<complex> Ei = Hz(-x, y);
plot(Ei, Hz, value = true, fill = true, wait = true);

/* Calculate transmittance (and reflectance) spectrum. */
complex a1, a2, a3, factor, r, t;	// Complex amplitudes and factor.
int order = 0, order2 = 0;		// Phase unfolding
real phase, oldval = 0, oldval2 = 0;	// variables.

cout << "# k\t|t_e|^2\targ(t_e)\t|t_m|^2\targ(t_m)" << endl;
for (k = 0.005; k < 1.0; k += 0.005) {
	/* Solve  E||z polarization. */
	{
		matrix<complex> A = dynamice(Sh, Sh);
		complex[int] b = dynamice(0, Sh);
		Ez[] = A^-1 * b;
	}

	/* Decomposition into incident, reflected and transmitted waves. */
	a1 = int1d(Th, m1) (Ez);
	a2 = int1d(Th, m2) (Ez);
	a3 = int1d(Th, m3) (Ez);
	factor = exp(-1i * k * (y2 - y1));
	r = exp(1i * k * (y1 + y2)) * (a1 - a2 * factor) / (a2 - a1 * factor);
	t = 2i * exp(1i * k * (d + y1 - y3)) *
	    sin(k * (y2 - y1)) * a3 / (a2 - a1 * factor);

	/* Unfold phase. */
	phase = arg(t);
	if ((oldval > 0) && (phase < 0) && (abs(oldval - phase) > pi))
		order++;
	if ((oldval < 0) && (phase > 0) && (abs(oldval - phase) > pi))
		order--;
	oldval = phase;

	cout << k << "\t" << abs(t)^2 << "\t" <<
	    phase + 2 * pi * order << "\t";

	/* Solve H||z polarization. */
	{
		matrix<complex> A = dynamich(Veh, Veh);
		complex[int] b = dynamich(0, Veh);
		Ex[] = A^-1 * b;
	}
	Hz = -1i / k * (dx(Ey) - dy(Ex));

	/* Decomposition into incident, reflected and transmitted waves. */
	a1 = int1d(Th, m1) (Hz);
	a2 = int1d(Th, m2) (Hz);
	a3 = int1d(Th, m3) (Hz);
	factor = exp(-1i * k * (y2 - y1));
	r = exp(1i * k * (y1 + y2)) * (a1 - a2 * factor) / (a2 - a1 * factor);
	t = 2i * exp(1i * k * (d + y1 - y3)) *
	    sin(k * (y2 - y1)) * a3 / (a2 - a1 * factor);

	/* Unfold phase. */
	phase = arg(t);
	if ((oldval2 > 0) && (phase < 0) && (abs(oldval2 - phase) > pi))
		order2++;
	if ((oldval2 < 0) && (phase > 0) && (abs(oldval2 - phase) > pi))
		order2--;
	oldval2 = phase;

	cout << abs(t)^2 << "\t" <<
	    phase + 2 * pi * order2 << endl;
}
