/* Parameters. */

//verbosity = 0;

real stripe = 0.2;			// Fraction of metal.
real inlen = 4;				// Length of incident side.
real outlen = 2;			// Length of outgoing side.
real d = 0.5;				// Dielectric thickness.
					// Period is set to 1.0.
int nin = 20 * inlen;			// Discretization of incident side.
int nout = 20 * outlen;			// Discretization of outgoing side.
int n = 10;				// Discretization of periodic side.
int nst = 100 * stripe;			// Discretization of a stripe.
int nround = 10;			// Discretization of a rounded path.
int nmid = 10;				// Discretization of a midline.

real delta = stripe * pi^2 / 16 / nst^2; // Smallest cell size.

/* Exponents for nodes distribution on in and out sides. */
real alphain = log((inlen / (stripe * pi / 4 / nst) - 1) / nin);
real alphaout = log((outlen / (stripe * pi / 4 / nst) - 1) / nout);

/* Labels identifiers. */
int lb = 1;
int rb = 2;
int inl = 3;
int outl = 4;
int stl = 5;
int str = 6;
int pathleft = 7;
int pathright = 8;

/* Outer borders. */
border leftin(t = 0, 1){x = -0.5; y = -(exp(alphain * t) - 1) /
    (exp(alphain) - 1) * (inlen - delta) - delta; label = lb;}
border leftinst(t = 0, -1){x = -0.5; y = t * delta; label = lb;}
border leftout(t = 1, 0){x = -0.5; y = (exp(alphaout * t) - 1) /
    (exp(alphaout) - 1) * (outlen - delta) + delta; label = lb;}
border leftoutst(t = 1, 0){x = -0.5; y = t * delta; label = lb;}
border rightout(t = 0, 1){x = 0.5; y = (exp(alphaout * t) - 1) /
    (exp(alphaout) - 1) * (outlen - delta) + delta; label = rb;}
border rightoutst(t = 0, 1){x = 0.5; y = t * delta; label = rb;}
border rightin(t = 1, 0){x = 0.5; y = -(exp(alphain * t) - 1) /
    (exp(alphain) - 1) * (inlen - delta) - delta; label = rb;}
border rightinst(t = -1, 0){x = 0.5; y = t * delta; label = rb;}
border in(t = -0.5, 0.5){x = t; y = -inlen; label = inl;}
border out(t = 0.5, -0.5){x = t; y = outlen; label = outl;}

/* Metal stripe. */
border stripebl(t = 0, pi / 2){x = 0.5 - 0.5 * stripe * cos(t); y = 0;
    label = stl;}
border stripebr(t = pi / 2, pi){x = -0.5 - 0.5 * stripe * cos(t); y = 0;
    label = str;}

/* A line to relax mesh density in the gap. */
border midline(t = -0.5, 0.5){x = 0; y = (1 - stripe) * t;}

/* Integration path. */
border pathlowleft(t = 0, pi / 2){x = 0.5 - 0.5 * stripe * cos(t);
    y = -delta; label = pathleft;}
border pathlowright(t = pi / 2, pi){x = -0.5 - 0.5 * stripe * cos(t);
    y = -delta; label = pathright;}
border pathcircright(t = -pi / 2, pi / 2){x = -0.5 + 0.5 * stripe +
    delta * cos(t); y = delta * sin(t); label = pathright;}
border pathupright(t = 0, pi / 2){x = -0.5 + 0.5 * stripe * cos(t);
    y = delta; label = pathright;}
border pathupleft(t = pi / 2, pi){x = 0.5 + 0.5 * stripe * cos(t);
    y = delta; label = pathleft;}
border pathcircleft(t = pi / 2, 3 * pi / 2){x = 0.5 - 0.5 * stripe +
    delta * cos(t); y = delta * sin(t); label = pathleft;}

/* Mesh. */
mesh Th = buildmesh(in(n) + rightin(nin) + rightinst(1) + rightoutst(1) +
    rightout(nout) + out(n) + leftout(nout) + leftoutst(1) + leftinst(1) +
    leftin(nin) + stripebl(nst) + stripebr(nst) + midline(nmid) +
    pathlowleft(nst) + pathcircleft(nround) + pathupleft(nst) +
    pathlowright(nst) + pathcircright(nround) + pathupright(nst));
//    fixedborder = true);

/* Dielectric permittivity. */
func epsilon = 1 + 0 * ((y > 0) && (y < d));

/* Electrostatic problem. */
varf static(u, v)
	= int2d(Th) (epsilon * [dx(v), dy(v)]' * [dx(u), dy(u)]) +
	on(stl, u = -0.5) + on(str, u = 0.5) +
	on(inl, outl, lb, rb, u = -x);

/* Periodic scalar function space. */
//fespace Sph(Th, P2, periodic = [[li, y], [ri, y], [lo, y], [ro, y]]);

/* Scalar function space. */
fespace Sh(Th, P2);

/* Vector function space. */
fespace Vh(Th, [P1, P1]);

/* Unknown potential. */
Sh u;

/* Solve static linear system. */
{
	matrix A = static(Sh, Sh);
	real[int] b = static(0, Sh);
	u[] = A^-1 * b;
}

/* Electric field. */
Vh [Ex, Ey] = [-dx(u), -dy(u)];

/* Charges and areas. */
real qleft = int1d(Th, pathleft) ([Ex, Ey]' * [N.x, N.y]);
real areanormleft = int1d(Th, pathleft) (1.0);
real qright = int1d(Th, pathright) ([Ex, Ey]' * [N.x, N.y]);
real areanormright = int1d(Th, pathright) (1.0);

/* Output static results. */
cout << "arealeft = " << areanormleft << ", arearight = " << areanormright <<
    ", qleft = " << qleft << ", qright = " << qright << endl;
plot(u, [Ex, Ey], value = true, fill = true, wait = true);
