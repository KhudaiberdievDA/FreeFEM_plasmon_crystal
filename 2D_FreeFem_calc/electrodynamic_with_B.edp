load	"Element_Mixte"

/* Parameters. */

//verbosity = 0;

real stripe = 23. / 25;		// Fraction of metal.
real inlen = 4;				// Length of incident side.
real outlen = 4;			// Length of outgoing side.
real d = 50.0 / 25;			// Dielectric thickness.
complex dieleps = 12;			// Dielectric epsilon.
real sigma0 = 5;			// 2D conductivity 4 * pi * sigma / c.
real tau = 1.0 / (2 * pi * 25e-4 * 1.5);	// c * tau / period.
real k = 0.8;				// Wavevector times period.
real kc= 0;
					// Period is set to 1.0.
int nin = 20 * inlen;			// Discretization of incident side.
int nout = 20 * outlen;			// Discretization of outgoing side.
int ninh = 10 * inlen;			// Discretization of incident side.
int nouth = 10 * outlen;		// Discretization of outgoing side.
int n = 5;				// Discretization of periodic side.
int nst = 100 * stripe;			// Discretization of a stripe.
int nmid = 20;				// Discretization of a midline.
int nanim = 40;				// Number of animation frames.

real delta = stripe * pi^2 / 16 / nst^2; // Smallest cell size.

/* Exponents for nodes distribution on in and out sides. */
real alphainr = log((inlen / (stripe * pi / 4 / nst) - 1) / nin);
real alphaoutr = log((outlen / (stripe * pi / 4 / nst) - 1) / nout);
real alphainl = log((inlen / ((1 - stripe) / nmid) - 1) / nin);
real alphaoutl = log((outlen / ((1 - stripe) / nmid) - 1) / nout);

/* Labels identifiers. */
int lb = 1;
int rb = 2;
int inl = 3;
int outl = 4;
int st = 5;

/* Homogeneously spaced borders (half of geometry). */
border leftinh(t = 0, 1){x = 0; y = -t * inlen; label = lb;}
border leftouth(t = 1, 0){x = 0; y = t * outlen; label = lb;}
border rightouth(t = 0, 1){x = 0.5; y = t * outlen; label = rb;}
border rightinh(t = 1, 0){x = 0.5; y = -t * inlen; label = rb;}
border stripeb(t = 0, 0.5){x = t; y = 0; label = st;}

/* Outer borders (half of geometry). */
border leftin(t = 0, 1){x = 0; y = -(exp(alphainl * t) - 1) /
    (exp(alphainl) - 1) * inlen; label = lb;}
border leftout(t = 1, 0){x = 0; y = (exp(alphaoutl * t) - 1) /
    (exp(alphaoutl) - 1) * outlen; label = lb;}
border rightout(t = 0, 1){x = 0.5; y = (exp(alphaoutr * t) - 1) /
    (exp(alphaoutr) - 1) * outlen; label = rb;}
border rightin(t = 1, 0){x = 0.5; y = -(exp(alphainr * t) - 1) /
    (exp(alphainr) - 1) * inlen; label = rb;}
border in(t = 0, 0.5){x = t; y = -inlen; label = inl;}
border out(t = 0.5, 0){x = t; y = outlen; label = outl;}

/* Metal stripe (half). */
border stripebh(t = 0, pi / 2){x = 0.5 - 0.5 * stripe * cos(t); y = 0;
    label = st;}

/* Mesh. */
mesh Th = buildmesh(in(n) + out(n) +
    rightin(nin) + rightout(nout) + leftout(nout) + leftin(nin) +
    stripebh(nst));
//    rightinh(ninh) + rightouth(nouth) + leftouth(nouth) + leftinh(ninh) +
//    stripeb(n));

/* Dielectric permittivity. */
func epsilon = 1 + (dieleps - 1) * ((y > 0) && (y < d));


/* Drude conductivity. */ //!with B
// func sigmaXX = sigma0 / (1 - 1i * k * tau);
// real kc = 0.1;
func sigmaXX = sigma0 * (1 - 1i * k * tau)/( (1 - 1i * k * tau)^2 + (kc * tau)^2 );
func sigmaXY = sigma0 * (- kc * tau)      /( (1 - 1i * k * tau)^2 + (kc * tau)^2 );

/* Electrodynamic problem, E||z polarization. */
//! NEW
varf dynamiceBoth([uz, ux, uy], [vz, vx, vy])
	= int2d(Th) ([dx(vz), dy(vz)]' * [dx(uz), dy(uz)] -
	    epsilon * k^2 * vz * uz)
	- int1d(Th, st) (1i * k * vz * (sigmaXX * uz + sigmaXY * ux) )
	- int1d(Th, outl) (1i * k * vz * uz)
	+ on(inl, uz = 1)
	+ int2d(Th) ((dx(vy) - dy(vx)) * (dx(uy) - dy(ux)) -
	    epsilon * k^2 * [vx, vy]' * [ux, uy])
	- int1d(Th, st) (1i * k * vx * (sigmaXX * ux - sigmaXY * uz))
	- int1d(Th, outl) (1i * k * vx * ux)
	+ on(inl, lb, rb, ux = 1i, uy = 0);
	// + on(inl, ux = 0, uy = 0);

/* Electrodynamic problem, H||z polarization. */
//! NEW
varf dynamichBoth([uz, ux, uy], [vz, vx, vy])
	= int2d(Th) ([dx(vz), dy(vz)]' * [dx(uz), dy(uz)] -
	    epsilon * k^2 * vz * uz)
	- int1d(Th, st) (1i * k * vz * (sigmaXX * uz + sigmaXY * ux) )
	- int1d(Th, outl) (1i * k * vz * uz)
	+ on(inl, uz = -1i)
	+ int2d(Th) ((dx(vy) - dy(vx)) * (dx(uy) - dy(ux)) -
	    epsilon * k^2 * [vx, vy]' * [ux, uy])
	- int1d(Th, st) (1i * k * vx * (sigmaXX * ux - sigmaXY * uz))
	- int1d(Th, outl) (1i * k * vx * ux)
	+ on(inl, lb, rb, ux = 1, uy = 0);
	// + on(inl, ux = 1, uy = 0);

/* E||z (scalar) and H||xy (vector) function spaces. */
fespace Sh(Th, P2);
fespace Vh(Th, [P1, P1]);

/* E||xy (Nedelec, edge) and H||z (scalar) function spaces. */
fespace Veh(Th, RT1Ortho);
fespace Seh(Th, P1);

//! NEW for the whole vector E
fespace ShVeh(Th,[P2,RT1Ortho]);

/* Auxiliary scalar field. */
Sh aux;


//! Any polarization of E!
/* Unknown field. */
ShVeh<complex> [Ez,Ex,Ey];
// Sh<complex> Ez;

/* Solve dynamic linear system. E||z*/
{
	matrix<complex> A = dynamiceBoth(ShVeh, ShVeh);
	complex[int] b = dynamiceBoth(0, ShVeh);
	Ez[] = A^-1 * b; //! Why does it even work??? It also gives Ex and Ey the correct data
}

/* Magnetic field. */
Vh<complex> [Hx, Hy] = [-1i / k * dy(Ez), 1i / k * dx(Ez)];
Seh<complex> Hz = -1i / k * (dx(Ey) - dy(Ex));

/* Output dynamic results. */
plot(Ez,[Ex,Ey], value = true, fill = true, wait = true);
// plot(Ey, value = true, fill = true, wait = true);
// plot(Ez, value = true, fill = true, wait = true);
plot(Hz,[Hx,Hy], value = true, fill = true, wait = true);
// plot(Hy, value = true, fill = true, wait = true);
// plot(Hz, value = true, fill = true, wait = true);


/* Solve dynamic linear system. H||z*/
{
	matrix<complex> A = dynamichBoth(ShVeh, ShVeh);
	complex[int] b = dynamichBoth(0, ShVeh);
	Ez[] = A^-1 * b; //! Why does it even work??? It also gives Ex and Ey the correct data
}


/* Magnetic field. */
Hz = -1i / k * (dx(Ey) - dy(Ex));
[Hx, Hy] = [-1i / k * dy(Ez), 1i / k * dx(Ez)];

/* Output dynamic results. */

/* Output dynamic results. */
plot(Ez,[Ex,Ey], value = true, fill = true, wait = true);
// plot(Ey, value = true, fill = true, wait = true);
// plot(Ez, value = true, fill = true, wait = true);
plot(Hz,[Hx,Hy], value = true, fill = true, wait = true);
// plot(Hy, value = true, fill = true, wait = true);
// plot(Hz, value = true, fill = true, wait = true);



/* Find the amplitude of the waves. */
// aux = abs(Ez);
// real am = aux[].max;
// real step = am / 20;

/* Visualize the wave. */
// real[int] viso = -(am + step):step:(am + step);
// for (int i = 0; i < -nanim; i++) {
// 	aux = real(Ez) * cos(2 * pi * i / nanim) +
// 	    imag(Ez) * sin(2 * pi * i / nanim);
// 	plot(aux, value = true, fill = true, viso = viso, dim = 2);
// }



/* Calculate transmittance (and reflectance) spectrum. */
// cout << "# k\tR_el\tT_el\tR_magn\tT_magn" << endl;
// for (k = 0.005; k < 1; k += 0.005) {
// 	/* Solve  E||z polarization. */
// 	{
// 		matrix<complex> A = dynamiceBoth(ShVeh, ShVeh);
// 		complex[int] b = dynamiceBoth(0, ShVeh);
// 		Ez[] = A^-1 * b; 
// 	}

















// 	/* Decomposition into incident, reflected and transmitted waves. */
// 	complex a1 = Ez(0, -inlen);
// 	complex a2 = Ez(0, -inlen / 2);
// 	complex a3 = Ez(0, outlen);
// 	complex factor = exp(-1i * k * inlen / 2);
// 	real R = abs((a1 - a2 * factor) / (a2 - a1 * factor))^2;
// 	real T = 4 * sin(k * inlen / 2)^2 * abs(a3 / (a2 - a1 * factor))^2;
// 	cout << k << "\t" << R << "\t" << T << "\t";

// 	/* Solve H||z polarization. */
// 	{
// 		matrix<complex> A = dynamichBoth(ShVeh, ShVeh);
// 		complex[int] b = dynamichBoth(0, ShVeh);
// 		Ez[] = A^-1 * b; 
// 	}
// 	Hz = -1i / k * (dx(Ey) - dy(Ex));

// 	/* Decomposition into incident, reflected and transmitted waves. */
// 	a1 = Hz(0, -inlen);
// 	a2 = Hz(0, -inlen / 2);
// 	a3 = Hz(0, outlen);
// 	factor = exp(-1i * k * inlen / 2);
// 	R = abs((a1 - a2 * factor) / (a2 - a1 * factor))^2;
// 	T = 4 * sin(k * inlen / 2)^2 * abs(a3 / (a2 - a1 * factor))^2;
// 	cout << R << "\t" << T << endl;
// }


/* Calculate transmittance (and reflectance) spectrum. */
// cout << "# k\tR_el\tT_el\tR_magn\tT_magn" << endl;
// for (k = 0.005; k < 1; k += 0.005) {
// 	/* Solve  E||z polarization. */
// 	{
// 		matrix<complex> A = dynamiceBoth(ShVeh, ShVeh);
// 		complex[int] b = dynamiceBoth(0, ShVeh);
// 		Ez[] = A^-1 * b; 
// 	}

// 	/* Decomposition into incident, reflected and transmitted waves. */
// 	complex EzA1 = Ez(0, -inlen);
// 	complex EzA2 = Ez(0, -inlen / 2);
// 	complex EzA3 = Ez(0, outlen);
// 	complex ExA1 = Ex(0, -inlen);
// 	complex ExA2 = Ex(0, -inlen / 2);
// 	complex ExA3 = Ex(0, outlen);
// 	complex factor = exp(-1i * k * inlen / 2);
// 	real R = abs((EzA1 - EzA2 * factor) / (EzA2 - EzA1 * factor))^2;
// 	real T = 4 * sin(k * inlen / 2)^2 * abs(EzA3 / (EzA2 - EzA1 * factor))^2;
// 	cout << k << "\t" << R << "\t" << T << "\t";

// 	/* Solve H||z polarization. */
// 	{
// 		matrix<complex> A = dynamichBoth(ShVeh, ShVeh);
// 		complex[int] b = dynamichBoth(0, ShVeh);
// 		Ez[] = A^-1 * b; 
// 	}
	// Hz = -1i / k * (dx(Ey) - dy(Ex));

// 	/* Decomposition into incident, reflected and transmitted waves. */
// 	complex EzB1 = Ez(0, -inlen);
// 	complex EzB2 = Ez(0, -inlen / 2);
// 	complex EzB3 = Ez(0, outlen);
// 	complex ExB1 = Ex(0, -inlen);
// 	complex ExB2 = Ex(0, -inlen / 2);
// 	complex ExB3 = Ex(0, outlen);
// 	factor = exp(-1i * k * inlen / 2);
// 	R = abs((ExB1 - ExB2 * factor) / (ExB2 - ExB1 * factor))^2;
// 	T = 4 * sin(k * inlen / 2)^2 * abs(ExB3 / (ExB2 - ExB1 * factor))^2;

	

// 	cout << R << "\t" << T << endl;
// }