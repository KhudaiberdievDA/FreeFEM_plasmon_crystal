//  run with MPI:  ff-mpirun -np 4 script.edp

load "msh3"
load "medit"
load "gmsh"
load "Element_Mixte"
load "PETSc"                        // PETSc plugin
load "UMFPACK64"
// include "ffmatlib.idp"



ofstream log("3D_simulation/eigenvalues.log");
/* Parameters. */

verbosity = 0;

// real n = 5E11/sqrt(5.5); // concentration in cm^(-2)
real n = 5E11; // concentration in cm^(-2)
real tauS = 2E-11; // relaxation time in seconds
real c = 2.99792458E10; // speed of light in cm/s
real e = 4.80320425E-10; // electron charge in esu
real pi = 3.141592653589793; // pi
real massElectron = 9.10938356E-28; // electron mass in grams
real mCyclotron = 0.47; // cyclotron mass in units of electron mass
real massRelation = 5.5; // mx/my ratio

real a = 25e-4;				// Stripes period [cm].
real dieleps = 1;           // Dielectric epsilon as complex
real sigma0 =  4*pi/c * e^2*n*tauS/mCyclotron/massElectron; // 2D conductivity 4 * pi / c * sigma .
// real gamma = 1.5 * 5 / sigma0;		// 1/Tau in cm^(-1)
// real tau = 1.0 / (2 * pi * gamma * a);	// c * tau / period.
real tau = c*tauS/a;	// c * tau / period.
// real k = 2 * pi * a * 2000 / 29.98;	// Wavevector times period.
real k = 0.001;	// Wavevector times period.
func f =  k * c / (2 * pi * a) * 1E-9;	// Frequency in GHz.
					// Period is set to 1.0.
// real kcr1 = 2 * pi * a * (-12.7);	// Cyclotron resonance in 1 Tesla. Needs to be checked!
real kcr1 = -1.655603E12 * sigma0 / n / tau;	// Cyclotron resonance in 1 Tesla. Needs to be checked!
real kcr = kcr1 * 0;			// Cyclotron resonance wave vector.
complex polx = 1.0, polz = 0.0;   // Incident polarization as complex

/* Labels and scale factor (should be synchronized with GMSH file). */
int sIn = 1;
int sOut = 2;
int sSource = 3;
int sBack = 4;
int sM1 = 5;
int sM2 = 6;
int sM3 = 7;
int sBoundaryBottom = 8;
int sBoundaryTop = 9;
int sBoundaryLeft = 10;
int sBoundaryRight = 11;
int sCircle = 12;
int sComplimentary = 13;
int vDiel = 14;
int vAir = 15;
real scale = 1.0 / 1e3;

// Load the 3D mesh from gmsh
lockOrientation = false;
// mesh3 Th = gmshload3("3D_simulation/circle_dense.msh");
mesh3 Th = gmshload3("3D_simulation/circle_dense.msh");
// plot(Th,wait=1);
int[int] labs = labels(Th);
lockOrientation = true;

Th = movemesh(Th, [scale * x, scale * y, scale * z]);

// Display mesh information
cout << "=== Mesh Information ===" << endl;
cout << "Number of tetrahedra: " << Th.nt << endl;
cout << "Number of vertices: " << Th.nv << endl;
cout << "Number of boundary elements: " << Th.nbe << endl;



// Define Edge13d finite element space (H(curl) conforming)
// fespace Vh3 (Th, Edge03d, periodic =
//     [[sBoundaryBottom, x, y], [sBoundaryTop, x, y], 
//      [sBoundaryLeft, y, z], [sBoundaryRight, y, z]]);

// Also define P1 space for potential problems
fespace Vh(Th, P1, periodic =
	[[sBoundaryBottom, x, y], [sBoundaryTop, x, y], 
	[sBoundaryLeft, y, z], [sBoundaryRight, y, z]]); //Periodic Scalar


/* Get the positions of planes m1, m2, m3 and the back of the sample. */
real y1 = int2d(Th, sM1) (y)   / int2d(Th, sM1) (1);
real y2 = int2d(Th, sM2) (y)   / int2d(Th, sM2) (1);
real y3 = int2d(Th, sM3) (y)   / int2d(Th, sM3) (1);
real d  = int2d(Th, sBack) (y) / int2d(Th, sBack) (1);
log << "m1 = " << y1 << ", m2 = " << y2 << ", m3 = " << y3 <<    ", d = " << d << endl;

// Solve the generalized eigenvalue problem
int nev = 26; // number of eigenvalues to compute
real sigma = 3; // shift for the shift-invert method


/* Dielectric permittivity. */
func epsilon = 1 * (Th(x, y, z).region == vAir) +
    dieleps * (Th(x, y, z).region == vDiel);

macro anisoTensor [[sqrt(massRelation),0],[0,1/sqrt(massRelation)]] //

Vh u, v;

/*Macros for 2D Nabla operator*/
macro Nabla2D(w) [dx(w), dz(w)] //

/*Macros for 3D Nabla operator*/
macro Nabla3D(w) [dx(w), dy(w), dz(w)] //

// varf BVarf(u, v) =
//     int2d(Th,sCircle)( Nabla2D(u)' * anisoTensor * Nabla2D(v) );

// varf AVarf(u, v) =
//     int3d(Th)( epsilon * Nabla3D(u)' * Nabla3D(v)) - int2d(Th,sCircle)(sigma * Nabla2D(u)' * anisoTensor * Nabla2D(v));

varf AVarf(u, v) =
    int2d(Th,sCircle)( Nabla2D(u)' * anisoTensor * Nabla2D(v))
    - int3d(Th)(sigma * epsilon * Nabla3D(u)' * Nabla3D(v));

varf BVarf(u, v) =
    int3d(Th)( epsilon * Nabla3D(u)' * Nabla3D(v));


matrix OP = AVarf(Vh, Vh, solver=Crout, factorize=1);
matrix B = BVarf(Vh, Vh, solver=CG, eps=1e-20);

cout << "Assembled matrices." << endl;

real[int] ev(nev);
Vh[int]   eV(nev);


int m = EigenValue(OP, B, sym=true, sigma=sigma, value=ev, vector=eV, tol=1e-10, maxit=0, ncv=0);
// int m = EigenValue(OP, B, mode = 2, sym=true, value=ev, vector=eV, tol=1e-10, maxit=0, ncv=0);

for (int i = 0; i < m; i++){
    cout << "lambda[" << i << "] = " << ev[i] << endl;
    // medit("U",Th,eV[i]);
    plot(eV[i], cmm="Eigen Vector "+i+" value ="+ev[i], wait=true, value=true);
    savevtk("solution_lambda_"+ev[i]+".vtk", Th, eV[i], dataname="u");
}